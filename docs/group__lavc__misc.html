<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EdenCore: Utility functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EdenCore<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Utility functions<div class="ingroups"><a class="el" href="group__libavc.html">libavcodec</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Utility functions:</div>
<div class="dyncontent">
<div class="center"><img src="group__lavc__misc.png" border="0" usemap="#agroup____lavc____misc" alt=""/></div>
<map name="agroup____lavc____misc" id="agroup____lavc____misc">
<area shape="rect" href="group__lavc__fft.html" title=" " alt="" coords="299,5,401,31"/>
<area shape="rect" title=" " alt="" coords="139,31,251,56"/>
<area shape="rect" href="group__lavc__misc__pixfmt.html" title=" " alt="" coords="301,55,399,80"/>
<area shape="rect" href="group__libavc.html" title=" " alt="" coords="5,31,91,56"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__lavc__misc__pixfmt"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc__pixfmt.html">Pixel formats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__lavc__fft"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__fft.html">FFT functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9faedcb004233fde71b5c4ed2c45fb8c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga9faedcb004233fde71b5c4ed2c45fb8c">AVBitStreamFilterContext</a></td></tr>
<tr class="separator:ga9faedcb004233fde71b5c4ed2c45fb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7a013315e444069ec9630ddf3edce3f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga7a013315e444069ec9630ddf3edce3f8">AVLockOp</a> { <a class="el" href="group__lavc__misc.html#gga7a013315e444069ec9630ddf3edce3f8a486a4a2d7a97554c2e073536c038465d">AV_LOCK_CREATE</a>
, <a class="el" href="group__lavc__misc.html#gga7a013315e444069ec9630ddf3edce3f8af684bbd8575f2686f42346f5e43be673">AV_LOCK_OBTAIN</a>
, <a class="el" href="group__lavc__misc.html#gga7a013315e444069ec9630ddf3edce3f8a7c470cd815cdef3b16a977e9a8c89c69">AV_LOCK_RELEASE</a>
, <a class="el" href="group__lavc__misc.html#gga7a013315e444069ec9630ddf3edce3f8aee9ae55e2efe16565998e473c2a18935">AV_LOCK_DESTROY</a>
 }</td></tr>
<tr class="separator:ga7a013315e444069ec9630ddf3edce3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf91030a62b10ff4446fcf35c1a8eca8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gaf91030a62b10ff4446fcf35c1a8eca8d">av_get_codec_tag_string</a> (char *<a class="el" href="core__dispatch_8h.html#a37cdef99116453a9b49eb77e9cd899b8">buf</a>, size_t buf_size, unsigned int codec_tag)</td></tr>
<tr class="separator:gaf91030a62b10ff4446fcf35c1a8eca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4056568b5ab73d2e55800d9a5caa66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga6d4056568b5ab73d2e55800d9a5caa66">avcodec_string</a> (char *<a class="el" href="core__dispatch_8h.html#a37cdef99116453a9b49eb77e9cd899b8">buf</a>, int buf_size, <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *<a class="el" href="pem_8h.html#ad6fdb41b50e78f467a47521d4ce3707b">enc</a>, int encode)</td></tr>
<tr class="separator:ga6d4056568b5ab73d2e55800d9a5caa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94924e4132bfde3ec08f94ef8671503"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gaf94924e4132bfde3ec08f94ef8671503">av_get_profile_name</a> (const <a class="el" href="struct_a_v_codec.html">AVCodec</a> *codec, int profile)</td></tr>
<tr class="separator:gaf94924e4132bfde3ec08f94ef8671503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c9160585074829625a88069747dea2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga56c9160585074829625a88069747dea2">avcodec_profile_name</a> (enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> codec_id, int profile)</td></tr>
<tr class="separator:ga56c9160585074829625a88069747dea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ccd730ba6e891b6c61da68ab138c63f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga9ccd730ba6e891b6c61da68ab138c63f">avcodec_default_execute</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c, int(*func)(<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c2, void *arg2), void *arg, int *ret, int count, int <a class="el" href="group__lavu__mem__funcs.html#ga34e10fdac079a9ca4512b8ccd7f20b8a">size</a>)</td></tr>
<tr class="separator:ga9ccd730ba6e891b6c61da68ab138c63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga365b89d7f5b6dc9f930f07ec4078a611"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga365b89d7f5b6dc9f930f07ec4078a611">avcodec_default_execute2</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c, int(*func)(<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c2, void *arg2, int, int), void *arg, int *ret, int count)</td></tr>
<tr class="separator:ga365b89d7f5b6dc9f930f07ec4078a611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b44aad56fa22a78fb8916eb8cc0516"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga66b44aad56fa22a78fb8916eb8cc0516">avcodec_fill_audio_frame</a> (<a class="el" href="struct_a_v_frame.html">AVFrame</a> *frame, int nb_channels, enum <a class="el" href="group__lavu__sampfmts.html#gaf9a51ca15301871723577c730b5865c5">AVSampleFormat</a> sample_fmt, const uint8_t *<a class="el" href="core__dispatch_8h.html#a37cdef99116453a9b49eb77e9cd899b8">buf</a>, int buf_size, int align)</td></tr>
<tr class="separator:ga66b44aad56fa22a78fb8916eb8cc0516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60b0e076f822abcb2700eb601d352a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gaf60b0e076f822abcb2700eb601d352a6">avcodec_flush_buffers</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *avctx)</td></tr>
<tr class="separator:gaf60b0e076f822abcb2700eb601d352a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0717e7440fdb123f708082f66cd9b41d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga0717e7440fdb123f708082f66cd9b41d">av_get_bits_per_sample</a> (enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> codec_id)</td></tr>
<tr class="separator:ga0717e7440fdb123f708082f66cd9b41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa5775a0bd6a6ab58011e8492156eb6e"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gafa5775a0bd6a6ab58011e8492156eb6e">av_get_pcm_codec</a> (enum <a class="el" href="group__lavu__sampfmts.html#gaf9a51ca15301871723577c730b5865c5">AVSampleFormat</a> <a class="el" href="core__dispatch_8h.html#aca1c8c6b462e11524fad002ff90fece9">fmt</a>, int be)</td></tr>
<tr class="separator:gafa5775a0bd6a6ab58011e8492156eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadddbcd146ffaf53016bac730c631f7b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gadddbcd146ffaf53016bac730c631f7b3">av_get_exact_bits_per_sample</a> (enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> codec_id)</td></tr>
<tr class="separator:gadddbcd146ffaf53016bac730c631f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3266a8c3df0790c62259f91afcde45a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga3266a8c3df0790c62259f91afcde45a9">av_get_audio_frame_duration</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *avctx, int frame_bytes)</td></tr>
<tr class="separator:ga3266a8c3df0790c62259f91afcde45a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4495d5092c1f58283ff9a16352b4e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga1f4495d5092c1f58283ff9a16352b4e1">av_get_audio_frame_duration2</a> (<a class="el" href="struct_a_v_codec_parameters.html">AVCodecParameters</a> *par, int frame_bytes)</td></tr>
<tr class="separator:ga1f4495d5092c1f58283ff9a16352b4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8f7eec28df88d590eb3b3d865cf0ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga6d8f7eec28df88d590eb3b3d865cf0ca">av_register_bitstream_filter</a> (<a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> *bsf)</td></tr>
<tr class="separator:ga6d8f7eec28df88d590eb3b3d865cf0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03cee6c31452fa7a56f9dae46ccae1a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga03cee6c31452fa7a56f9dae46ccae1a9">av_bitstream_filter_init</a> (const char *name)</td></tr>
<tr class="separator:ga03cee6c31452fa7a56f9dae46ccae1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aa30391ba53516321c69ec0cea34e39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga8aa30391ba53516321c69ec0cea34e39">av_bitstream_filter_filter</a> (<a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a> *bsfc, <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *avctx, const char *args, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *<a class="el" href="core__dispatch_8h.html#a37cdef99116453a9b49eb77e9cd899b8">buf</a>, int buf_size, int keyframe)</td></tr>
<tr class="separator:ga8aa30391ba53516321c69ec0cea34e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga294d399ec25bf1fd3c92ccd085654c76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga294d399ec25bf1fd3c92ccd085654c76">av_bitstream_filter_close</a> (<a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a> *bsf)</td></tr>
<tr class="separator:ga294d399ec25bf1fd3c92ccd085654c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e94df669aedcf1f9deb9f9e01fadbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> const <a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga96e94df669aedcf1f9deb9f9e01fadbb">av_bitstream_filter_next</a> (const <a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> *f)</td></tr>
<tr class="separator:ga96e94df669aedcf1f9deb9f9e01fadbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c7eedd5b04abaddeb5bc7f2f639ec2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> const <a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga5c7eedd5b04abaddeb5bc7f2f639ec2b">av_bsf_next</a> (void **opaque)</td></tr>
<tr class="separator:ga5c7eedd5b04abaddeb5bc7f2f639ec2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a23a2336412504052d5c4e0c7716ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga04a23a2336412504052d5c4e0c7716ee">av_fast_padded_malloc</a> (void *<a class="el" href="core__dispatch_8h.html#aaf0497a3bd20a0066017546af6bf80be">ptr</a>, unsigned int *<a class="el" href="group__lavu__mem__funcs.html#ga34e10fdac079a9ca4512b8ccd7f20b8a">size</a>, size_t min_size)</td></tr>
<tr class="separator:ga04a23a2336412504052d5c4e0c7716ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5550dc9271f356631f7002772158d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gaea5550dc9271f356631f7002772158d8">av_fast_padded_mallocz</a> (void *<a class="el" href="core__dispatch_8h.html#aaf0497a3bd20a0066017546af6bf80be">ptr</a>, unsigned int *<a class="el" href="group__lavu__mem__funcs.html#ga34e10fdac079a9ca4512b8ccd7f20b8a">size</a>, size_t min_size)</td></tr>
<tr class="separator:gaea5550dc9271f356631f7002772158d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga144411ccbce77847ee9ce10d7fe5361c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga144411ccbce77847ee9ce10d7fe5361c">av_xiphlacing</a> (unsigned char *s, unsigned int v)</td></tr>
<tr class="separator:ga144411ccbce77847ee9ce10d7fe5361c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b2b1fe93195e596fa39676c5c4a295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga79b2b1fe93195e596fa39676c5c4a295">av_register_hwaccel</a> (<a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *hwaccel)</td></tr>
<tr class="separator:ga79b2b1fe93195e596fa39676c5c4a295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546639997ed756c5b262c75a4a1d59bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga546639997ed756c5b262c75a4a1d59bd">av_hwaccel_next</a> (const <a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *hwaccel)</td></tr>
<tr class="separator:ga546639997ed756c5b262c75a4a1d59bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9a0032df8f76cc766846514cebfab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga4e9a0032df8f76cc766846514cebfab7">av_lockmgr_register</a> (int(*<a class="el" href="pem_8h.html#aad1159769a72ead14e2eee7bcef6e1d7">cb</a>)(void **mutex, enum <a class="el" href="group__lavc__misc.html#ga7a013315e444069ec9630ddf3edce3f8">AVLockOp</a> op))</td></tr>
<tr class="separator:ga4e9a0032df8f76cc766846514cebfab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga906dda732e79eac12067c6d7ea19b630"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#ga906dda732e79eac12067c6d7ea19b630">avcodec_is_open</a> (<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *s)</td></tr>
<tr class="separator:ga906dda732e79eac12067c6d7ea19b630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30823cc24dc743ad5cf87e2c90629c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_c_p_b_properties.html">AVCPBProperties</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__misc.html#gab30823cc24dc743ad5cf87e2c90629c2">av_cpb_properties_alloc</a> (size_t *<a class="el" href="group__lavu__mem__funcs.html#ga34e10fdac079a9ca4512b8ccd7f20b8a">size</a>)</td></tr>
<tr class="separator:gab30823cc24dc743ad5cf87e2c90629c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Miscellaneous utility functions related to both encoding and decoding (or neither). </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga9faedcb004233fde71b5c4ed2c45fb8c" name="ga9faedcb004233fde71b5c4ed2c45fb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9faedcb004233fde71b5c4ed2c45fb8c">&#9670;&nbsp;</a></span>AVBitStreamFilterContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a> <a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga7a013315e444069ec9630ddf3edce3f8" name="ga7a013315e444069ec9630ddf3edce3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a013315e444069ec9630ddf3edce3f8">&#9670;&nbsp;</a></span>AVLockOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__misc.html#ga7a013315e444069ec9630ddf3edce3f8">AVLockOp</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Lock operation used by lockmgr</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>Deprecated together with <a class="el" href="group__lavc__misc.html#ga4e9a0032df8f76cc766846514cebfab7">av_lockmgr_register()</a>. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7a013315e444069ec9630ddf3edce3f8a486a4a2d7a97554c2e073536c038465d" name="gga7a013315e444069ec9630ddf3edce3f8a486a4a2d7a97554c2e073536c038465d"></a>AV_LOCK_CREATE&#160;</td><td class="fielddoc"><p >Create a mutex. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7a013315e444069ec9630ddf3edce3f8af684bbd8575f2686f42346f5e43be673" name="gga7a013315e444069ec9630ddf3edce3f8af684bbd8575f2686f42346f5e43be673"></a>AV_LOCK_OBTAIN&#160;</td><td class="fielddoc"><p >Lock the mutex. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7a013315e444069ec9630ddf3edce3f8a7c470cd815cdef3b16a977e9a8c89c69" name="gga7a013315e444069ec9630ddf3edce3f8a7c470cd815cdef3b16a977e9a8c89c69"></a>AV_LOCK_RELEASE&#160;</td><td class="fielddoc"><p >Unlock the mutex. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7a013315e444069ec9630ddf3edce3f8aee9ae55e2efe16565998e473c2a18935" name="gga7a013315e444069ec9630ddf3edce3f8aee9ae55e2efe16565998e473c2a18935"></a>AV_LOCK_DESTROY&#160;</td><td class="fielddoc"><p >Free mutex resources. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga294d399ec25bf1fd3c92ccd085654c76" name="ga294d399ec25bf1fd3c92ccd085654c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga294d399ec25bf1fd3c92ccd085654c76">&#9670;&nbsp;</a></span>av_bitstream_filter_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_bitstream_filter_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a> *&#160;</td>
          <td class="paramname"><em>bsf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd>the old bitstream filtering API (using <a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a>) is deprecated. Use <a class="el" href="group__lavc__core.html#ga08d53431e76355f88e27763b1940df4f">av_bsf_free()</a> from the new bitstream filtering API (using <a class="el" href="struct_a_v_b_s_f_context.html">AVBSFContext</a>). </dd></dl>

</div>
</div>
<a id="ga8aa30391ba53516321c69ec0cea34e39" name="ga8aa30391ba53516321c69ec0cea34e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aa30391ba53516321c69ec0cea34e39">&#9670;&nbsp;</a></span>av_bitstream_filter_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_bitstream_filter_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a> *&#160;</td>
          <td class="paramname"><em>bsfc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>poutbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>poutbuf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyframe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd>the old bitstream filtering API (using <a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a>) is deprecated. Use <a class="el" href="group__lavc__core.html#gaada9ea8f08d3dcf23c14564dbc88992c">av_bsf_send_packet()</a> and <a class="el" href="group__lavc__core.html#ga7fffb6c87b91250956e7a2367af56b38">av_bsf_receive_packet()</a> from the new bitstream filtering API (using <a class="el" href="struct_a_v_b_s_f_context.html">AVBSFContext</a>). </dd></dl>

</div>
</div>
<a id="ga03cee6c31452fa7a56f9dae46ccae1a9" name="ga03cee6c31452fa7a56f9dae46ccae1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03cee6c31452fa7a56f9dae46ccae1a9">&#9670;&nbsp;</a></span>av_bitstream_filter_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a> * av_bitstream_filter_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>the old bitstream filtering API (using <a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a>) is deprecated. Use <a class="el" href="group__lavc__core.html#gaf8f648184b420406a694f1867aaab839">av_bsf_get_by_name()</a>, <a class="el" href="group__lavc__core.html#ga7da65af303e20c9546e15ec266b182c1">av_bsf_alloc()</a>, and <a class="el" href="group__lavc__core.html#ga242529d54013acf87e94273d298a5ff2">av_bsf_init()</a> from the new bitstream filtering API (using <a class="el" href="struct_a_v_b_s_f_context.html">AVBSFContext</a>). </dd></dl>

</div>
</div>
<a id="ga96e94df669aedcf1f9deb9f9e01fadbb" name="ga96e94df669aedcf1f9deb9f9e01fadbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96e94df669aedcf1f9deb9f9e01fadbb">&#9670;&nbsp;</a></span>av_bitstream_filter_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> const <a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> * av_bitstream_filter_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>the old bitstream filtering API (using <a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a>) is deprecated. Use <a class="el" href="group__lavc__core.html#ga18b9f1195b8bc559b466dec20a9ab305">av_bsf_iterate()</a> from the new bitstream filtering API (using <a class="el" href="struct_a_v_b_s_f_context.html">AVBSFContext</a>). </dd></dl>

</div>
</div>
<a id="ga5c7eedd5b04abaddeb5bc7f2f639ec2b" name="ga5c7eedd5b04abaddeb5bc7f2f639ec2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c7eedd5b04abaddeb5bc7f2f639ec2b">&#9670;&nbsp;</a></span>av_bsf_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> const <a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> * av_bsf_next </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>opaque</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab30823cc24dc743ad5cf87e2c90629c2" name="gab30823cc24dc743ad5cf87e2c90629c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab30823cc24dc743ad5cf87e2c90629c2">&#9670;&nbsp;</a></span>av_cpb_properties_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_c_p_b_properties.html">AVCPBProperties</a> * av_cpb_properties_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate a CPB properties structure and initialize its fields to default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>if non-NULL, the size of the allocated struct will be written here. This is useful for embedding it in side data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated struct or NULL on failure </dd></dl>

</div>
</div>
<a id="ga04a23a2336412504052d5c4e0c7716ee" name="ga04a23a2336412504052d5c4e0c7716ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04a23a2336412504052d5c4e0c7716ee">&#9670;&nbsp;</a></span>av_fast_padded_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_fast_padded_malloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Same behaviour av_fast_malloc but the buffer has additional AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.</p>
<p >In addition the whole buffer will initially and after resizes be 0-initialized so that no uninitialized data will ever appear. </p>

</div>
</div>
<a id="gaea5550dc9271f356631f7002772158d8" name="gaea5550dc9271f356631f7002772158d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea5550dc9271f356631f7002772158d8">&#9670;&nbsp;</a></span>av_fast_padded_mallocz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_fast_padded_mallocz </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Same behaviour av_fast_padded_malloc except that buffer will always be 0-initialized after call. </p>

</div>
</div>
<a id="ga3266a8c3df0790c62259f91afcde45a9" name="ga3266a8c3df0790c62259f91afcde45a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3266a8c3df0790c62259f91afcde45a9">&#9670;&nbsp;</a></span>av_get_audio_frame_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_get_audio_frame_duration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return audio frame duration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avctx</td><td>codec context </td></tr>
    <tr><td class="paramname">frame_bytes</td><td>size of the frame, or 0 if unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>frame duration, in samples, if known. 0 if not able to determine. </dd></dl>

</div>
</div>
<a id="ga1f4495d5092c1f58283ff9a16352b4e1" name="ga1f4495d5092c1f58283ff9a16352b4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4495d5092c1f58283ff9a16352b4e1">&#9670;&nbsp;</a></span>av_get_audio_frame_duration2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_get_audio_frame_duration2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_parameters.html">AVCodecParameters</a> *&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is the same as <a class="el" href="group__lavc__misc.html#ga3266a8c3df0790c62259f91afcde45a9">av_get_audio_frame_duration()</a>, except it works with <a class="el" href="struct_a_v_codec_parameters.html">AVCodecParameters</a> instead of an <a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a>. </p>

</div>
</div>
<a id="ga0717e7440fdb123f708082f66cd9b41d" name="ga0717e7440fdb123f708082f66cd9b41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0717e7440fdb123f708082f66cd9b41d">&#9670;&nbsp;</a></span>av_get_bits_per_sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_get_bits_per_sample </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td>
          <td class="paramname"><em>codec_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return codec bits per sample.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>the codec </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bits per sample or zero if unknown for the given codec. </dd></dl>

</div>
</div>
<a id="gaf91030a62b10ff4446fcf35c1a8eca8d" name="gaf91030a62b10ff4446fcf35c1a8eca8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf91030a62b10ff4446fcf35c1a8eca8d">&#9670;&nbsp;</a></span>av_get_codec_tag_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> size_t av_get_codec_tag_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>codec_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Put a string representing the codec tag codec_tag in buf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to place codec tag in </td></tr>
    <tr><td class="paramname">buf_size</td><td>size in bytes of buf </td></tr>
    <tr><td class="paramname">codec_tag</td><td>codec tag to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string that would have been generated if enough space had been available, excluding the trailing null</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>see <a class="el" href="group__lavu__misc.html#ga79cdcd61b8d4c275681360af4430b513">av_fourcc_make_string()</a> and <a class="el" href="group__lavu__misc.html#gae07d7cbf511060210152a89ad0d137ad">av_fourcc2str()</a>. </dd></dl>

</div>
</div>
<a id="gadddbcd146ffaf53016bac730c631f7b3" name="gadddbcd146ffaf53016bac730c631f7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadddbcd146ffaf53016bac730c631f7b3">&#9670;&nbsp;</a></span>av_get_exact_bits_per_sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_get_exact_bits_per_sample </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td>
          <td class="paramname"><em>codec_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return codec bits per sample. Only return non-zero if the bits per sample is exactly correct, not an approximation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codec_id</td><td>the codec </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bits per sample or zero if unknown for the given codec. </dd></dl>

</div>
</div>
<a id="gafa5775a0bd6a6ab58011e8492156eb6e" name="gafa5775a0bd6a6ab58011e8492156eb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa5775a0bd6a6ab58011e8492156eb6e">&#9670;&nbsp;</a></span>av_get_pcm_codec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> av_get_pcm_codec </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavu__sampfmts.html#gaf9a51ca15301871723577c730b5865c5">AVSampleFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>be</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the PCM codec associated with a sample format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">be</td><td>endianness, 0 for little, 1 for big, -1 (or anything else) for native </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE </dd></dl>

</div>
</div>
<a id="gaf94924e4132bfde3ec08f94ef8671503" name="gaf94924e4132bfde3ec08f94ef8671503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf94924e4132bfde3ec08f94ef8671503">&#9670;&nbsp;</a></span>av_get_profile_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * av_get_profile_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_v_codec.html">AVCodec</a> *&#160;</td>
          <td class="paramname"><em>codec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a name for the specified profile, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codec</td><td>the codec that is searched for the given profile </td></tr>
    <tr><td class="paramname">profile</td><td>the profile value for which a name is requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A name for the profile if found, NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga546639997ed756c5b262c75a4a1d59bd" name="ga546639997ed756c5b262c75a4a1d59bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga546639997ed756c5b262c75a4a1d59bd">&#9670;&nbsp;</a></span>av_hwaccel_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> * av_hwaccel_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *&#160;</td>
          <td class="paramname"><em>hwaccel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If hwaccel is NULL, returns the first registered hardware accelerator, if hwaccel is non-NULL, returns the next registered hardware accelerator after hwaccel, or NULL if hwaccel is the last one.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>AVHWaccel structures contain no user-serviceable parts, so this function should not be used. </dd></dl>

</div>
</div>
<a id="ga4e9a0032df8f76cc766846514cebfab7" name="ga4e9a0032df8f76cc766846514cebfab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e9a0032df8f76cc766846514cebfab7">&#9670;&nbsp;</a></span>av_lockmgr_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_lockmgr_register </td>
          <td>(</td>
          <td class="paramtype">int(*)(void **mutex, enum <a class="el" href="group__lavc__misc.html#ga7a013315e444069ec9630ddf3edce3f8">AVLockOp</a> op)&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Register a user provided lock manager supporting the operations specified by AVLockOp. The "mutex" argument to the function points to a (void *) where the lockmgr should store/get a pointer to a user allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the value left by the last call for all other ops. If the lock manager is unable to perform the op then it should leave the mutex in the same state as when it was called and return a non-zero value. However, when called with AV_LOCK_DESTROY the mutex will always be assumed to have been successfully destroyed. If av_lockmgr_register succeeds it will return a non-negative value, if it fails it will return a negative value and destroy all mutex and unregister all callbacks. av_lockmgr_register is not thread-safe, it must be called from a single thread before any calls which make use of locking are used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>User defined callback. av_lockmgr_register invokes calls to this callback and the previously registered callback. The callback will be used to create more than one mutex each of which must be backed by its own underlying locking mechanism (i.e. do not use a single static object to implement your lock manager). If cb is set to NULL the lockmgr will be unregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>This function does nothing, and always returns 0. Be sure to build with thread support to get basic thread safety. </dd></dl>

</div>
</div>
<a id="ga6d8f7eec28df88d590eb3b3d865cf0ca" name="ga6d8f7eec28df88d590eb3b3d865cf0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d8f7eec28df88d590eb3b3d865cf0ca">&#9670;&nbsp;</a></span>av_register_bitstream_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_register_bitstream_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_bit_stream_filter.html">AVBitStreamFilter</a> *&#160;</td>
          <td class="paramname"><em>bsf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>the old bitstream filtering API (using <a class="el" href="struct_a_v_bit_stream_filter_context.html">AVBitStreamFilterContext</a>) is deprecated. Use the new bitstream filtering API (using <a class="el" href="struct_a_v_b_s_f_context.html">AVBSFContext</a>). </dd></dl>

</div>
</div>
<a id="ga79b2b1fe93195e596fa39676c5c4a295" name="ga79b2b1fe93195e596fa39676c5c4a295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79b2b1fe93195e596fa39676c5c4a295">&#9670;&nbsp;</a></span>av_register_hwaccel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_register_hwaccel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_h_w_accel.html">AVHWAccel</a> *&#160;</td>
          <td class="paramname"><em>hwaccel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Register the hardware accelerator hwaccel.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>This function doesn't do anything. </dd></dl>

</div>
</div>
<a id="ga144411ccbce77847ee9ce10d7fe5361c" name="ga144411ccbce77847ee9ce10d7fe5361c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga144411ccbce77847ee9ce10d7fe5361c">&#9670;&nbsp;</a></span>av_xiphlacing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int av_xiphlacing </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Encode extradata length to a buffer. Used by xiph codecs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>buffer to write to; must be at least (v/255+1) bytes long </td></tr>
    <tr><td class="paramname">v</td><td>size of extradata in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to the buffer. </dd></dl>

</div>
</div>
<a id="ga9ccd730ba6e891b6c61da68ab138c63f" name="ga9ccd730ba6e891b6c61da68ab138c63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ccd730ba6e891b6c61da68ab138c63f">&#9670;&nbsp;</a></span>avcodec_default_execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avcodec_default_execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c2, void *arg2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga365b89d7f5b6dc9f930f07ec4078a611" name="ga365b89d7f5b6dc9f930f07ec4078a611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga365b89d7f5b6dc9f930f07ec4078a611">&#9670;&nbsp;</a></span>avcodec_default_execute2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avcodec_default_execute2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(<a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *c2, void *arg2, int, int)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga66b44aad56fa22a78fb8916eb8cc0516" name="ga66b44aad56fa22a78fb8916eb8cc0516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b44aad56fa22a78fb8916eb8cc0516">&#9670;&nbsp;</a></span>avcodec_fill_audio_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avcodec_fill_audio_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_frame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__sampfmts.html#gaf9a51ca15301871723577c730b5865c5">AVSampleFormat</a>&#160;</td>
          <td class="paramname"><em>sample_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fill <a class="el" href="struct_a_v_frame.html">AVFrame</a> audio data and linesize pointers.</p>
<p >The buffer buf must be a preallocated buffer with a size big enough to contain the specified samples amount. The filled <a class="el" href="struct_a_v_frame.html">AVFrame</a> data pointers will point to this buffer.</p>
<p ><a class="el" href="struct_a_v_frame.html">AVFrame</a> extended_data channel pointers are allocated if necessary for planar audio.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>the <a class="el" href="struct_a_v_frame.html">AVFrame</a> frame-&gt;nb_samples must be set prior to calling the function. This function fills in frame-&gt;data, frame-&gt;extended_data, frame-&gt;linesize[0]. </td></tr>
    <tr><td class="paramname">nb_channels</td><td>channel count </td></tr>
    <tr><td class="paramname">sample_fmt</td><td>sample format </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to use for frame data </td></tr>
    <tr><td class="paramname">buf_size</td><td>size of buffer </td></tr>
    <tr><td class="paramname">align</td><td>plane size sample alignment (0 = default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 on success, negative error code on failure </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>return the size in bytes required to store the samples in case of success, at the next libavutil bump </dd></dl>

</div>
</div>
<a id="gaf60b0e076f822abcb2700eb601d352a6" name="gaf60b0e076f822abcb2700eb601d352a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf60b0e076f822abcb2700eb601d352a6">&#9670;&nbsp;</a></span>avcodec_flush_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avcodec_flush_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reset the internal codec state / flush internal buffers. Should be called e.g. when seeking or when switching to a different stream.</p>
<dl class="section note"><dt>Note</dt><dd>for decoders, when refcounted frames are not used (i.e. avctx-&gt;refcounted_frames is 0), this invalidates the frames previously returned from the decoder. When refcounted frames are used, the decoder just releases any references it might keep internally, but the caller's reference remains valid.</dd>
<dd>
for encoders, this function will only do something if the encoder declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder will drain any remaining packets, and can then be re-used for a different stream (as opposed to sending a null frame which will leave the encoder in a permanent EOF state after draining). This can be desirable if the cost of tearing down and replacing the encoder instance is high. </dd></dl>

</div>
</div>
<a id="ga906dda732e79eac12067c6d7ea19b630" name="ga906dda732e79eac12067c6d7ea19b630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga906dda732e79eac12067c6d7ea19b630">&#9670;&nbsp;</a></span>avcodec_is_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avcodec_is_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a positive value if s is open (i.e. <a class="el" href="group__lavc__core.html#ga11f785a188d7d9df71621001465b0f1d">avcodec_open2()</a> was called on it with no corresponding <a class="el" href="group__lavc__core.html#gaf4daa92361efb3523ef5afeb0b54077f">avcodec_close()</a>), 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga56c9160585074829625a88069747dea2" name="ga56c9160585074829625a88069747dea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c9160585074829625a88069747dea2">&#9670;&nbsp;</a></span>avcodec_profile_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * avcodec_profile_name </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td>
          <td class="paramname"><em>codec_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a name for the specified profile, if available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codec_id</td><td>the ID of the codec to which the requested profile belongs </td></tr>
    <tr><td class="paramname">profile</td><td>the profile value for which a name is requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A name for the profile if found, NULL otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>unlike <a class="el" href="group__lavc__misc.html#gaf94924e4132bfde3ec08f94ef8671503">av_get_profile_name()</a>, which searches a list of profiles supported by a specific decoder or encoder implementation, this function searches the list of profiles from the <a class="el" href="struct_a_v_codec_descriptor.html">AVCodecDescriptor</a> </dd></dl>

</div>
</div>
<a id="ga6d4056568b5ab73d2e55800d9a5caa66" name="ga6d4056568b5ab73d2e55800d9a5caa66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d4056568b5ab73d2e55800d9a5caa66">&#9670;&nbsp;</a></span>avcodec_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avcodec_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_v_codec_context.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>encode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
