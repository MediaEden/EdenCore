<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EdenCore: AVHWFramesContext Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EdenCore<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_a_v_h_w_frames_context-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AVHWFramesContext Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="hwcontext_8h_source.html">hwcontext.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for AVHWFramesContext:</div>
<div class="dyncontent">
<div class="center"><img src="struct_a_v_h_w_frames_context__coll__graph.png" border="0" usemap="#a_a_v_h_w_frames_context_coll__map" alt="Collaboration graph"/></div>
<map name="a_a_v_h_w_frames_context_coll__map" id="a_a_v_h_w_frames_context_coll__map">
<area shape="rect" title=" " alt="" coords="107,365,259,392"/>
<area shape="rect" href="struct_a_v_class.html" title=" " alt="" coords="13,185,85,212"/>
<area shape="rect" href="struct_a_v_h_w_device_context.html" title=" " alt="" coords="109,276,257,303"/>
<area shape="rect" href="struct_a_v_option.html" title=" " alt="" coords="10,95,89,121"/>
<area shape="rect" href="struct_a_v_rational.html" title=" " alt="" coords="5,5,93,32"/>
<area shape="rect" href="struct_a_v_buffer_ref.html" title=" " alt="" coords="281,276,375,303"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a70e916d610148748f95147cde35ce7c9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_v_class.html">AVClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#a70e916d610148748f95147cde35ce7c9">av_class</a></td></tr>
<tr class="separator:a70e916d610148748f95147cde35ce7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e956e8d2d73d65d015c4ed895ec642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hwcontext_8h.html#a01b62f32bcd517164857e7b5f5359f85">AVHWFramesInternal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#a69e956e8d2d73d65d015c4ed895ec642">internal</a></td></tr>
<tr class="separator:a69e956e8d2d73d65d015c4ed895ec642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3908bfadd569103b67ee4972ee7305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_buffer_ref.html">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#a2f3908bfadd569103b67ee4972ee7305">device_ref</a></td></tr>
<tr class="separator:a2f3908bfadd569103b67ee4972ee7305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a7dbd0cbfcabc0b1529cb34cf53b6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_v_h_w_device_context.html">AVHWDeviceContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#ac9a7dbd0cbfcabc0b1529cb34cf53b6d">device_ctx</a></td></tr>
<tr class="separator:ac9a7dbd0cbfcabc0b1529cb34cf53b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e38c3e4355321e23e0f4c7411cb8ee"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#a54e38c3e4355321e23e0f4c7411cb8ee">hwctx</a></td></tr>
<tr class="separator:a54e38c3e4355321e23e0f4c7411cb8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeccab495e5027aa0402dea10bdcd166"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#aaeccab495e5027aa0402dea10bdcd166">free</a> )(struct <a class="el" href="struct_a_v_h_w_frames_context.html">AVHWFramesContext</a> *<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>)</td></tr>
<tr class="separator:aaeccab495e5027aa0402dea10bdcd166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6e4c17632bd6770654b7627722222e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#a4d6e4c17632bd6770654b7627722222e">user_opaque</a></td></tr>
<tr class="separator:a4d6e4c17632bd6770654b7627722222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67ff3a5828a611d1b1cddd64fc1de71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__bufferpool.html#ga13bc8038952b61bae4d591f30c7421f6">AVBufferPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#ad67ff3a5828a611d1b1cddd64fc1de71">pool</a></td></tr>
<tr class="separator:ad67ff3a5828a611d1b1cddd64fc1de71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3a94dcd9c96e19059b56a6bae9c764"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#a9c3a94dcd9c96e19059b56a6bae9c764">initial_pool_size</a></td></tr>
<tr class="separator:a9c3a94dcd9c96e19059b56a6bae9c764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045bc1713932804f6ceef170a5578e0e"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#a045bc1713932804f6ceef170a5578e0e">format</a></td></tr>
<tr class="separator:a045bc1713932804f6ceef170a5578e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663a9aceca97aa7b2426c9aba6543e4a"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#a663a9aceca97aa7b2426c9aba6543e4a">sw_format</a></td></tr>
<tr class="separator:a663a9aceca97aa7b2426c9aba6543e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6f29d0f744930cdd0e8bdff8771520"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#a9e6f29d0f744930cdd0e8bdff8771520">width</a></td></tr>
<tr class="separator:a9e6f29d0f744930cdd0e8bdff8771520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61bbe1d8645a0c573085e29f1d0a58f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_v_h_w_frames_context.html#ae61bbe1d8645a0c573085e29f1d0a58f">height</a></td></tr>
<tr class="separator:ae61bbe1d8645a0c573085e29f1d0a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This struct describes a set or pool of "hardware" frames (i.e. those with data not located in normal system memory). All the frames in the pool are assumed to be allocated in the same way and interchangeable.</p>
<p >This struct is reference-counted with the AVBuffer mechanism and tied to a given <a class="el" href="struct_a_v_h_w_device_context.html">AVHWDeviceContext</a> instance. The <a class="el" href="hwcontext_8h.html#a4ecba8a4ac10bfb324aa117f36b6be32">av_hwframe_ctx_alloc()</a> constructor yields a reference, whose data field points to the actual <a class="el" href="struct_a_v_h_w_frames_context.html">AVHWFramesContext</a> struct. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a70e916d610148748f95147cde35ce7c9" name="a70e916d610148748f95147cde35ce7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e916d610148748f95147cde35ce7c9">&#9670;&nbsp;</a></span>av_class</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_v_class.html">AVClass</a>* AVHWFramesContext::av_class</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A class for logging. </p>

</div>
</div>
<a id="ac9a7dbd0cbfcabc0b1529cb34cf53b6d" name="ac9a7dbd0cbfcabc0b1529cb34cf53b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a7dbd0cbfcabc0b1529cb34cf53b6d">&#9670;&nbsp;</a></span>device_ctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_h_w_device_context.html">AVHWDeviceContext</a>* AVHWFramesContext::device_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The parent <a class="el" href="struct_a_v_h_w_device_context.html">AVHWDeviceContext</a>. This is simply a pointer to device_ref-&gt;data provided for convenience.</p>
<p >Set by libavutil in <a class="el" href="hwcontext_8h.html#a66a7e1ebc7e459ce07d3de6639ac7e38">av_hwframe_ctx_init()</a>. </p>

</div>
</div>
<a id="a2f3908bfadd569103b67ee4972ee7305" name="a2f3908bfadd569103b67ee4972ee7305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3908bfadd569103b67ee4972ee7305">&#9670;&nbsp;</a></span>device_ref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_v_buffer_ref.html">AVBufferRef</a>* AVHWFramesContext::device_ref</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A reference to the parent <a class="el" href="struct_a_v_h_w_device_context.html">AVHWDeviceContext</a>. This reference is owned and managed by the enclosing <a class="el" href="struct_a_v_h_w_frames_context.html">AVHWFramesContext</a>, but the caller may derive additional references from it. </p>

</div>
</div>
<a id="a045bc1713932804f6ceef170a5578e0e" name="a045bc1713932804f6ceef170a5578e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045bc1713932804f6ceef170a5578e0e">&#9670;&nbsp;</a></span>format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a> AVHWFramesContext::format</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The pixel format identifying the underlying HW surface type.</p>
<p >Must be a hwaccel format, i.e. the corresponding descriptor must have the AV_PIX_FMT_FLAG_HWACCEL flag set.</p>
<p >Must be set by the user before calling <a class="el" href="hwcontext_8h.html#a66a7e1ebc7e459ce07d3de6639ac7e38">av_hwframe_ctx_init()</a>. </p>

</div>
</div>
<a id="aaeccab495e5027aa0402dea10bdcd166" name="aaeccab495e5027aa0402dea10bdcd166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeccab495e5027aa0402dea10bdcd166">&#9670;&nbsp;</a></span>free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* AVHWFramesContext::free) (struct <a class="el" href="struct_a_v_h_w_frames_context.html">AVHWFramesContext</a> *<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This field may be set by the caller before calling <a class="el" href="hwcontext_8h.html#a66a7e1ebc7e459ce07d3de6639ac7e38">av_hwframe_ctx_init()</a>.</p>
<p >If non-NULL, this callback will be called when the last reference to this context is unreferenced, immediately before it is freed. </p>

</div>
</div>
<a id="ae61bbe1d8645a0c573085e29f1d0a58f" name="ae61bbe1d8645a0c573085e29f1d0a58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61bbe1d8645a0c573085e29f1d0a58f">&#9670;&nbsp;</a></span>height</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVHWFramesContext::height</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54e38c3e4355321e23e0f4c7411cb8ee" name="a54e38c3e4355321e23e0f4c7411cb8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e38c3e4355321e23e0f4c7411cb8ee">&#9670;&nbsp;</a></span>hwctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AVHWFramesContext::hwctx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The format-specific data, allocated and freed automatically along with this context.</p>
<p >Should be cast by the user to the format-specific context defined in the corresponding header (hwframe_*.h) and filled as described in the documentation before calling <a class="el" href="hwcontext_8h.html#a66a7e1ebc7e459ce07d3de6639ac7e38">av_hwframe_ctx_init()</a>.</p>
<p >After any frames using this context are created, the contents of this struct should not be modified by the caller. </p>

</div>
</div>
<a id="a9c3a94dcd9c96e19059b56a6bae9c764" name="a9c3a94dcd9c96e19059b56a6bae9c764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3a94dcd9c96e19059b56a6bae9c764">&#9670;&nbsp;</a></span>initial_pool_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVHWFramesContext::initial_pool_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initial size of the frame pool. If a device type does not support dynamically resizing the pool, then this is also the maximum pool size.</p>
<p >May be set by the caller before calling <a class="el" href="hwcontext_8h.html#a66a7e1ebc7e459ce07d3de6639ac7e38">av_hwframe_ctx_init()</a>. Must be set if pool is NULL and the device type does not support dynamic pools. </p>

</div>
</div>
<a id="a69e956e8d2d73d65d015c4ed895ec642" name="a69e956e8d2d73d65d015c4ed895ec642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e956e8d2d73d65d015c4ed895ec642">&#9670;&nbsp;</a></span>internal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hwcontext_8h.html#a01b62f32bcd517164857e7b5f5359f85">AVHWFramesInternal</a>* AVHWFramesContext::internal</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Private data used internally by libavutil. Must not be accessed in any way by the caller. </p>

</div>
</div>
<a id="ad67ff3a5828a611d1b1cddd64fc1de71" name="ad67ff3a5828a611d1b1cddd64fc1de71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67ff3a5828a611d1b1cddd64fc1de71">&#9670;&nbsp;</a></span>pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__bufferpool.html#ga13bc8038952b61bae4d591f30c7421f6">AVBufferPool</a>* AVHWFramesContext::pool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A pool from which the frames are allocated by <a class="el" href="hwcontext_8h.html#a03e7cf122b61f6472d0a4d37f52d4965">av_hwframe_get_buffer()</a>. This field may be set by the caller before calling <a class="el" href="hwcontext_8h.html#a66a7e1ebc7e459ce07d3de6639ac7e38">av_hwframe_ctx_init()</a>. The buffers returned by calling <a class="el" href="group__lavu__bufferpool.html#gabba08793f113e887e0693ff1ec0cb75f">av_buffer_pool_get()</a> on this pool must have the properties described in the documentation in the corresponding hw type's header (hwcontext_*.h). The pool will be freed strictly before this struct's <a class="el" href="struct_a_v_h_w_frames_context.html#aaeccab495e5027aa0402dea10bdcd166">free()</a> callback is invoked.</p>
<p >This field may be NULL, then libavutil will attempt to allocate a pool internally. Note that certain device types enforce pools allocated at fixed size (frame count), which cannot be extended dynamically. In such a case, initial_pool_size must be set appropriately. </p>

</div>
</div>
<a id="a663a9aceca97aa7b2426c9aba6543e4a" name="a663a9aceca97aa7b2426c9aba6543e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663a9aceca97aa7b2426c9aba6543e4a">&#9670;&nbsp;</a></span>sw_format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a> AVHWFramesContext::sw_format</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The pixel format identifying the actual data layout of the hardware frames.</p>
<p >Must be set by the caller before calling <a class="el" href="hwcontext_8h.html#a66a7e1ebc7e459ce07d3de6639ac7e38">av_hwframe_ctx_init()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>when the underlying API does not provide the exact data layout, but only the colorspace/bit depth, this field should be set to the fully planar version of that format (e.g. for 8-bit 420 YUV it should be AV_PIX_FMT_YUV420P, not AV_PIX_FMT_NV12 or anything else). </dd></dl>

</div>
</div>
<a id="a4d6e4c17632bd6770654b7627722222e" name="a4d6e4c17632bd6770654b7627722222e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6e4c17632bd6770654b7627722222e">&#9670;&nbsp;</a></span>user_opaque</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AVHWFramesContext::user_opaque</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Arbitrary user data, to be used e.g. by the <a class="el" href="struct_a_v_h_w_frames_context.html#aaeccab495e5027aa0402dea10bdcd166">free()</a> callback. </p>

</div>
</div>
<a id="a9e6f29d0f744930cdd0e8bdff8771520" name="a9e6f29d0f744930cdd0e8bdff8771520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6f29d0f744930cdd0e8bdff8771520">&#9670;&nbsp;</a></span>width</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AVHWFramesContext::width</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The allocated dimensions of the frames in this pool.</p>
<p >Must be set by the user before calling <a class="el" href="hwcontext_8h.html#a66a7e1ebc7e459ce07d3de6639ac7e38">av_hwframe_ctx_init()</a>. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>libdeps/include/libavutil/<a class="el" href="hwcontext_8h_source.html">hwcontext.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
