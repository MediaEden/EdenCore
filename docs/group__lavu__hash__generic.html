<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EdenCore: Generic Hashing API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EdenCore<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Generic Hashing API<div class="ingroups"><a class="el" href="group__lavu.html">libavutil</a> &raquo; <a class="el" href="group__lavu__crypto.html">Crypto and Hashing</a> &raquo; <a class="el" href="group__lavu__hash.html">Hash Functions</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Generic Hashing API:</div>
<div class="dyncontent">
<div class="center"><img src="group__lavu__hash__generic.png" border="0" usemap="#agroup____lavu____hash____generic" alt=""/></div>
<map name="agroup____lavu____hash____generic" id="agroup____lavu____hash____generic">
<area shape="rect" href="group__lavu__hash.html" title=" " alt="" coords="5,5,120,31"/>
<area shape="rect" title=" " alt="" coords="168,5,313,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:libdeps_2include_2libavutil_2hash_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libdeps_2include_2libavutil_2hash_8h.html">hash.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaff5173f8837eb3afbd20b52528833d72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gaff5173f8837eb3afbd20b52528833d72">AV_HASH_MAX_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:gaff5173f8837eb3afbd20b52528833d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad1e018687f3a0e9baf3fb6d3af0dd10b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gad1e018687f3a0e9baf3fb6d3af0dd10b">av_hash_alloc</a> (struct AVHashContext **<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>, const char *name)</td></tr>
<tr class="separator:gad1e018687f3a0e9baf3fb6d3af0dd10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd204c00234c1f0ed710376a448bc77d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gadd204c00234c1f0ed710376a448bc77d">av_hash_names</a> (int i)</td></tr>
<tr class="separator:gadd204c00234c1f0ed710376a448bc77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e12e548f508b11d02ec29abbabe8cb5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga5e12e548f508b11d02ec29abbabe8cb5">av_hash_get_name</a> (const struct AVHashContext *<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>)</td></tr>
<tr class="separator:ga5e12e548f508b11d02ec29abbabe8cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf8f94e3ebf73f838d017f83352d880"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size</a> (const struct AVHashContext *<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>)</td></tr>
<tr class="separator:ga8bf8f94e3ebf73f838d017f83352d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ef872a731eb5c2637ddcd0f0976bca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga84ef872a731eb5c2637ddcd0f0976bca">av_hash_init</a> (struct AVHashContext *<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>)</td></tr>
<tr class="separator:ga84ef872a731eb5c2637ddcd0f0976bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a467ff60cb5080b56e818e7b8adb4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gac6a467ff60cb5080b56e818e7b8adb4a">av_hash_update</a> (struct AVHashContext *<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>, const uint8_t *src, int <a class="el" href="x509_8h.html#ad8c3db4434e9cb5cd772cc009f40e856">len</a>)</td></tr>
<tr class="separator:gac6a467ff60cb5080b56e818e7b8adb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff9a69f576f8f94e33a0b43a08baa70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gaeff9a69f576f8f94e33a0b43a08baa70">av_hash_final</a> (struct AVHashContext *<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>, uint8_t *dst)</td></tr>
<tr class="separator:gaeff9a69f576f8f94e33a0b43a08baa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e1a59bf9c2076eda5884e89249af12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga65e1a59bf9c2076eda5884e89249af12">av_hash_final_bin</a> (struct AVHashContext *<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>, uint8_t *dst, int <a class="el" href="group__lavu__mem__funcs.html#ga34e10fdac079a9ca4512b8ccd7f20b8a">size</a>)</td></tr>
<tr class="separator:ga65e1a59bf9c2076eda5884e89249af12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8316ebcbe11caebc88b4c4afc0eef16c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga8316ebcbe11caebc88b4c4afc0eef16c">av_hash_final_hex</a> (struct AVHashContext *<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>, uint8_t *dst, int <a class="el" href="group__lavu__mem__funcs.html#ga34e10fdac079a9ca4512b8ccd7f20b8a">size</a>)</td></tr>
<tr class="separator:ga8316ebcbe11caebc88b4c4afc0eef16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2300a29e15fd439bcac2f9bc35b730ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga2300a29e15fd439bcac2f9bc35b730ca">av_hash_final_b64</a> (struct AVHashContext *<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>, uint8_t *dst, int <a class="el" href="group__lavu__mem__funcs.html#ga34e10fdac079a9ca4512b8ccd7f20b8a">size</a>)</td></tr>
<tr class="separator:ga2300a29e15fd439bcac2f9bc35b730ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8bac529966e9af25f3608d3a1515ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga1e8bac529966e9af25f3608d3a1515ab">av_hash_freep</a> (struct AVHashContext **<a class="el" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>)</td></tr>
<tr class="separator:ga1e8bac529966e9af25f3608d3a1515ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >An abstraction layer for all hash functions supported by libavutil.</p>
<p >If your application needs to support a wide range of different hash functions, then the Generic Hashing API is for you. It provides a generic, reusable API for <a class="el" href="group__lavu__hash.html">all hash functions</a> implemented in libavutil. If you just need to use one particular hash function, use the <a class="el" href="group__lavu__hash.html">individual hash</a> directly.</p>
<h1><a class="anchor" id="Sample"></a>
Code</h1>
<p >A basic template for using the Generic Hashing API follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>AVHashContext *<a class="code hl_variable" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a> = <a class="code hl_define" href="machine__type_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *hash_name = <a class="code hl_define" href="machine__type_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">uint8_t *output_buf = <a class="code hl_define" href="machine__type_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Select from a string returned by av_hash_names()</span></div>
<div class="line">hash_name = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Allocate a hash context</span></div>
<div class="line">ret = <a class="code hl_function" href="group__lavu__hash__generic.html#gad1e018687f3a0e9baf3fb6d3af0dd10b">av_hash_alloc</a>(&amp;<a class="code hl_variable" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>, hash_name);</div>
<div class="line"><span class="keywordflow">if</span> (ret &lt; 0)</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize the hash context</span></div>
<div class="line"><a class="code hl_function" href="group__lavu__hash__generic.html#ga84ef872a731eb5c2637ddcd0f0976bca">av_hash_init</a>(<a class="code hl_variable" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Update the hash context with data</span></div>
<div class="line"><span class="keywordflow">while</span> (data_left) {</div>
<div class="line">    <a class="code hl_function" href="group__lavu__hash__generic.html#gac6a467ff60cb5080b56e818e7b8adb4a">av_hash_update</a>(<a class="code hl_variable" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>, <a class="code hl_variable" href="core__dispatch_8h.html#ada790f55a73af1ee47deb2d66826c744">data</a>, <a class="code hl_variable" href="group__lavu__mem__funcs.html#ga34e10fdac079a9ca4512b8ccd7f20b8a">size</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now we have no more data, so it is time to finalize the hash and get the</span></div>
<div class="line"><span class="comment">// output. But we need to first allocate an output buffer. Note that you can</span></div>
<div class="line"><span class="comment">// use any memory allocation function, including malloc(), not just</span></div>
<div class="line"><span class="comment">// av_malloc().</span></div>
<div class="line">output_buf = <a class="code hl_function" href="group__lavu__mem__funcs.html#gaba88a97429de6874c1a0b64381034b98">av_malloc</a>(<a class="code hl_function" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size</a>(<a class="code hl_variable" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>));</div>
<div class="line"><span class="keywordflow">if</span> (!output_buf)</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_define" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR</a>(ENOMEM);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Finalize the hash context.</span></div>
<div class="line"><span class="comment">// You can use any of the av_hash_final*() functions provided, for other</span></div>
<div class="line"><span class="comment">// output formats. If you do so, be sure to adjust the memory allocation</span></div>
<div class="line"><span class="comment">// above. See the function documentation below for the exact amount of extra</span></div>
<div class="line"><span class="comment">// memory needed.</span></div>
<div class="line"><a class="code hl_function" href="group__lavu__hash__generic.html#gaeff9a69f576f8f94e33a0b43a08baa70">av_hash_final</a>(<a class="code hl_variable" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>, output_buffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Free the context</span></div>
<div class="line"><a class="code hl_function" href="group__lavu__hash__generic.html#ga1e8bac529966e9af25f3608d3a1515ab">av_hash_freep</a>(&amp;<a class="code hl_variable" href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a>);</div>
<div class="ttc" id="acore__dispatch_8h_html_a1795d4ea01d211a7398ecd541c6f1302"><div class="ttname"><a href="core__dispatch_8h.html#a1795d4ea01d211a7398ecd541c6f1302">ctx</a></div><div class="ttdeci">const char const char *mode OSSL_CORE_BIO const void size_t size_t *written char size_t const char va_list args OPENSSL_CORE_CTX * ctx</div><div class="ttdef"><b>Definition:</b> core_dispatch.h:180</div></div>
<div class="ttc" id="acore__dispatch_8h_html_ada790f55a73af1ee47deb2d66826c744"><div class="ttname"><a href="core__dispatch_8h.html#ada790f55a73af1ee47deb2d66826c744">data</a></div><div class="ttdeci">const char const char *mode OSSL_CORE_BIO const void * data</div><div class="ttdef"><b>Definition:</b> core_dispatch.h:166</div></div>
<div class="ttc" id="agroup__lavu__error_html_gae4bb6f165973d09584e0ec0f335f69ca"><div class="ttname"><a href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR</a></div><div class="ttdeci">#define AVERROR(e)</div><div class="ttdef"><b>Definition:</b> error.h:43</div></div>
<div class="ttc" id="agroup__lavu__hash__generic_html_ga1e8bac529966e9af25f3608d3a1515ab"><div class="ttname"><a href="group__lavu__hash__generic.html#ga1e8bac529966e9af25f3608d3a1515ab">av_hash_freep</a></div><div class="ttdeci">void av_hash_freep(struct AVHashContext **ctx)</div></div>
<div class="ttc" id="agroup__lavu__hash__generic_html_ga84ef872a731eb5c2637ddcd0f0976bca"><div class="ttname"><a href="group__lavu__hash__generic.html#ga84ef872a731eb5c2637ddcd0f0976bca">av_hash_init</a></div><div class="ttdeci">void av_hash_init(struct AVHashContext *ctx)</div></div>
<div class="ttc" id="agroup__lavu__hash__generic_html_ga8bf8f94e3ebf73f838d017f83352d880"><div class="ttname"><a href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size</a></div><div class="ttdeci">int av_hash_get_size(const struct AVHashContext *ctx)</div></div>
<div class="ttc" id="agroup__lavu__hash__generic_html_gac6a467ff60cb5080b56e818e7b8adb4a"><div class="ttname"><a href="group__lavu__hash__generic.html#gac6a467ff60cb5080b56e818e7b8adb4a">av_hash_update</a></div><div class="ttdeci">void av_hash_update(struct AVHashContext *ctx, const uint8_t *src, int len)</div></div>
<div class="ttc" id="agroup__lavu__hash__generic_html_gad1e018687f3a0e9baf3fb6d3af0dd10b"><div class="ttname"><a href="group__lavu__hash__generic.html#gad1e018687f3a0e9baf3fb6d3af0dd10b">av_hash_alloc</a></div><div class="ttdeci">int av_hash_alloc(struct AVHashContext **ctx, const char *name)</div></div>
<div class="ttc" id="agroup__lavu__hash__generic_html_gaeff9a69f576f8f94e33a0b43a08baa70"><div class="ttname"><a href="group__lavu__hash__generic.html#gaeff9a69f576f8f94e33a0b43a08baa70">av_hash_final</a></div><div class="ttdeci">void av_hash_final(struct AVHashContext *ctx, uint8_t *dst)</div></div>
<div class="ttc" id="agroup__lavu__mem__funcs_html_ga34e10fdac079a9ca4512b8ccd7f20b8a"><div class="ttname"><a href="group__lavu__mem__funcs.html#ga34e10fdac079a9ca4512b8ccd7f20b8a">size</a></div><div class="ttdeci">size_t size</div><div class="ttdef"><b>Definition:</b> mem.h:226</div></div>
<div class="ttc" id="agroup__lavu__mem__funcs_html_gaba88a97429de6874c1a0b64381034b98"><div class="ttname"><a href="group__lavu__mem__funcs.html#gaba88a97429de6874c1a0b64381034b98">av_malloc</a></div><div class="ttdeci">void * av_malloc(size_t size) av_malloc_attrib av_alloc_size(1)</div></div>
<div class="ttc" id="amachine__type_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="machine__type_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> machine_type.h:208</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Hash"></a>
Function-Specific Information</h1>
<p >If the CRC32 hash is selected, the <a class="el" href="group__lavu__crc32.html#ggab7717a9f1179a5ac8516982f9f2997d2a2c95e44f51d497669d7c49d58018dea1">AV_CRC_32_IEEE</a> polynomial will be used.</p>
<p >If the Murmur3 hash is selected, the default seed will be used. See <a class="el" href="group__lavu__murmur3.html#lavu_murmur3_seedinfo">Murmur3</a> for more information. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaff5173f8837eb3afbd20b52528833d72" name="gaff5173f8837eb3afbd20b52528833d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff5173f8837eb3afbd20b52528833d72">&#9670;&nbsp;</a></span>AV_HASH_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AV_HASH_MAX_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Maximum value that <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size()</a> will currently return.</p>
<p >You can use this if you absolutely want or need to use static allocation for the output buffer and are fine with not supporting hashes newly added to libavutil without recompilation.</p>
<dl class="section warning"><dt>Warning</dt><dd>Adding new hashes with larger sizes, and increasing the macro while doing so, will not be considered an ABI change. To prevent your code from overflowing a buffer, either dynamically allocate the output buffer with <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size()</a>, or limit your use of the Hashing API to hashes that are already in FFmpeg during the time of compilation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad1e018687f3a0e9baf3fb6d3af0dd10b" name="gad1e018687f3a0e9baf3fb6d3af0dd10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1e018687f3a0e9baf3fb6d3af0dd10b">&#9670;&nbsp;</a></span>av_hash_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_hash_alloc </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext **&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate a hash context for the algorithm specified by name.</p>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 for success, a negative error code for failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The context is not initialized after a call to this function; you must call <a class="el" href="group__lavu__hash__generic.html#ga84ef872a731eb5c2637ddcd0f0976bca">av_hash_init()</a> to do so. </dd></dl>

</div>
</div>
<a id="gaeff9a69f576f8f94e33a0b43a08baa70" name="gaeff9a69f576f8f94e33a0b43a08baa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff9a69f576f8f94e33a0b43a08baa70">&#9670;&nbsp;</a></span>av_hash_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_final </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finalize a hash context and compute the actual hash value.</p>
<p >The minimum size of <code>dst</code> buffer is given by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size()</a> or <a class="el" href="group__lavu__hash__generic.html#gaff5173f8837eb3afbd20b52528833d72">AV_HASH_MAX_SIZE</a>. The use of the latter macro is discouraged.</p>
<p >It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the final hash value will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavu__hash__generic.html#ga65e1a59bf9c2076eda5884e89249af12">av_hash_final_bin()</a> provides an alternative API </dd></dl>

</div>
</div>
<a id="ga2300a29e15fd439bcac2f9bc35b730ca" name="ga2300a29e15fd439bcac2f9bc35b730ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2300a29e15fd439bcac2f9bc35b730ca">&#9670;&nbsp;</a></span>av_hash_final_b64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_final_b64 </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finalize a hash context and store the Base64 representation of the actual hash value as a string.</p>
<p >It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<p >The string is always 0-terminated.</p>
<p >If <code>size</code> is smaller than <a class="el" href="group__lavu__base64.html#gaa79f39ca3f737b662ae6711d2cbecd20">AV_BASE64_SIZE(hash_size)</a>, where <code>hash_size</code> is the value returned by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size()</a>, the string will be truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the final hash value will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes to write to <code>dst</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65e1a59bf9c2076eda5884e89249af12" name="ga65e1a59bf9c2076eda5884e89249af12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65e1a59bf9c2076eda5884e89249af12">&#9670;&nbsp;</a></span>av_hash_final_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_final_bin </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finalize a hash context and store the actual hash value in a buffer.</p>
<p >It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<p >If <code>size</code> is smaller than the hash size (given by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size()</a>), the hash is truncated; if size is larger, the buffer is padded with 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the final hash value will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to write to <code>dst</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8316ebcbe11caebc88b4c4afc0eef16c" name="ga8316ebcbe11caebc88b4c4afc0eef16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8316ebcbe11caebc88b4c4afc0eef16c">&#9670;&nbsp;</a></span>av_hash_final_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_final_hex </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finalize a hash context and store the hexadecimal representation of the actual hash value as a string.</p>
<p >It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<p >The string is always 0-terminated.</p>
<p >If <code>size</code> is smaller than <code>2 * hash_size + 1</code>, where <code>hash_size</code> is the value returned by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size()</a>, the string will be truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the string will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes to write to <code>dst</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e8bac529966e9af25f3608d3a1515ab" name="ga1e8bac529966e9af25f3608d3a1515ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e8bac529966e9af25f3608d3a1515ab">&#9670;&nbsp;</a></span>av_hash_freep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_freep </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext **&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Free hash context and set hash context pointer to <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Pointer to hash context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e12e548f508b11d02ec29abbabe8cb5" name="ga5e12e548f508b11d02ec29abbabe8cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e12e548f508b11d02ec29abbabe8cb5">&#9670;&nbsp;</a></span>av_hash_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * av_hash_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the name of the algorithm corresponding to the given hash context. </p>

</div>
</div>
<a id="ga8bf8f94e3ebf73f838d017f83352d880" name="ga8bf8f94e3ebf73f838d017f83352d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf8f94e3ebf73f838d017f83352d880">&#9670;&nbsp;</a></span>av_hash_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_hash_get_size </td>
          <td>(</td>
          <td class="paramtype">const struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the size of the resulting hash value in bytes.</p>
<p >The maximum value this function will currently return is available as macro <a class="el" href="group__lavu__hash__generic.html#gaff5173f8837eb3afbd20b52528833d72">AV_HASH_MAX_SIZE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the hash value in bytes </dd></dl>

</div>
</div>
<a id="ga84ef872a731eb5c2637ddcd0f0976bca" name="ga84ef872a731eb5c2637ddcd0f0976bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84ef872a731eb5c2637ddcd0f0976bca">&#9670;&nbsp;</a></span>av_hash_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_init </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize or reset a hash context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd204c00234c1f0ed710376a448bc77d" name="gadd204c00234c1f0ed710376a448bc77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd204c00234c1f0ed710376a448bc77d">&#9670;&nbsp;</a></span>av_hash_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * av_hash_names </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the names of available hash algorithms.</p>
<p >This function can be used to enumerate the algorithms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the hash algorithm, starting from 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a static string or <code>NULL</code> if <code>i</code> is out of range </dd></dl>

</div>
</div>
<a id="gac6a467ff60cb5080b56e818e7b8adb4a" name="gac6a467ff60cb5080b56e818e7b8adb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a467ff60cb5080b56e818e7b8adb4a">&#9670;&nbsp;</a></span>av_hash_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_update </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Update a hash context with additional data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Data to be added to the hash context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of the additional data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
